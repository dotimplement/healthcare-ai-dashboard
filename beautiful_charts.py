import marimo

__generated_with = "0.17.8"
app = marimo.App(width="columns")


@app.cell(column=0)
def _():
    import marimo as mo
    import pandas as pd
    from datetime import datetime, timedelta
    import numpy as np

    return datetime, mo, np, pd, timedelta


@app.cell(hide_code=True)
def _(datetime, np, pd, timedelta):
    def load_and_process_data():
        """Load and process the healthcare repository data"""
        df = pd.read_csv("healthcare_data.csv")

        # Remove unimportant categories
        df = df[
            ~df["Category"].isin(
                [
                    "Lists",
                    "Tutorials",
                    "Specification / Docs",
                    "Archived / Deprecated",
                    "Educational",
                ]
            )
        ]

        # Convert to datetime
        df["Created"] = pd.to_datetime(df["Created"])
        df["Last Commit"] = pd.to_datetime(df["Last Commit"])

        # Create new columns
        today = datetime.now()
        df["days_since_last_commit"] = (today - df["Last Commit"]).apply(
            lambda x: x.days
        )
        df["contributor_count"] = (
            df["Top Contributors"].fillna("").str.split(",").apply(len)
        )
        df["Org"] = df["Repository"].str.split("/").str[0]

        # Active definition: committed within last 365 days
        df["recent_activity_category"] = np.where(
            df["days_since_last_commit"] < 365, "Active", "Inactive"
        )

        # Additional processing for visualizations
        df["first_commit"] = df["Created"]
        df["last_commit"] = df["Last Commit"]
        df["lifespan_days"] = (df["last_commit"] - df["first_commit"]).dt.days
        df["start_year"] = df["first_commit"].dt.year
        df["is_active"] = df["last_commit"] >= (today - timedelta(days=365))

        # Process Standard column - handle multiple standards
        df["Standard"] = df["Standard"].fillna("None/Unknown")
        df["has_standard"] = df["Standard"] != "None/Unknown"

        # Create exploded dataframe for multi-standard analysis
        df["standards_list"] = df["Standard"].apply(
            lambda x: [s.strip() for s in str(x).split(",") if s.strip()]
        )

        # Load the classified repos CSV (generated by the GitHub classifier script)
        classified_df = pd.read_csv("repos_classified.csv")

        classified_df.loc[
            classified_df["owner"] == "microsoft", "owner_type"
        ] = "Big Tech"
        classified_df.loc[
            classified_df["owner"] == "awslabs", "owner_type"
        ] = "Big Tech"
        classified_df.loc[classified_df["owner"] == "google", "owner_type"] = "Big Tech"

        # Create a mapping dictionary from owner to organization status
        owner_classification = (
            classified_df.drop_duplicates(subset=["owner"])
            .set_index("owner")[["is_organization", "owner_type"]]
            .to_dict("index")
        )

        # Apply the classification to your main dataframe
        df["is_organization"] = df["Org"].map(
            lambda x: owner_classification.get(x, {}).get("is_organization", None)
        )
        df["owner_type"] = df["Org"].map(
            lambda x: owner_classification.get(x, {}).get("owner_type", "Unknown")
        )

        df["Created_years"] = "Upto 2016"

        df.loc[df["Created"].dt.year >= 2016, "Created_years"] = "2016-2018"
        df.loc[df["Created"].dt.year >= 2019, "Created_years"] = "2019-2021"
        df.loc[df["Created"].dt.year >= 2022, "Created_years"] = "2022-2025"

        return df

    return (load_and_process_data,)


@app.cell
def _(load_and_process_data):
    df_health = load_and_process_data()
    return (df_health,)


@app.cell
def _(df_health):
    df_interop = df_health[df_health["Category"] == "Interoperability"]
    return (df_interop,)


@app.cell
def _(pd):
    df_ownership = pd.read_csv("./repos_classified.csv")
    return (df_ownership,)


@app.cell
def _(df_ownership, interop_top_repo_stars):
    df_ownership[df_ownership["full_name"].isin(list(interop_top_repo_stars.index))]
    return


@app.cell
def _():
    ## Time series of languages over time
    return


@app.cell
def _():
    ## Time series of subcats over time
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    ## Breakdown of HAI Repos
    """
    )
    return


@app.cell
def _(df_hai):
    df_hai
    return


@app.cell
def _(df_health, px):
    # TODO: Either make this into a simple time series or keep bar chart

    df_hai = df_health[df_health["Category"] == "HAI engineering"]

    _subcat_counts = df_hai["Subcat"].value_counts()

    _fig_subcat = px.bar(
        x=_subcat_counts.values,
        y=_subcat_counts.index,
        orientation="h",
        title=f"AI Machine go brrrrrrrrrrr",
        subtitle="Breakdown of HAI Engineering Repos",
        labels={"x": "Number of Repositories", "y": "Subcategory"},
        # color=_subcat_counts.values,
        # color_continuous_scale='Teal'
    )

    # Add values at the end of each bar
    _fig_subcat.update_traces(
        text=_subcat_counts.values, textposition="outside", textfont=dict(size=12)
    )

    _fig_subcat.update_layout(height=500, yaxis={"categoryorder": "total ascending"})

    _fig_subcat.update_layout(yaxis_title=None)
    _fig_subcat.update_layout(legend=None)
    _fig_subcat.update_layout()
    _fig_subcat.show()
    _fig_subcat.write_image("./nice_plots/hai_engineering.svg")
    return (df_hai,)


@app.cell
def _():
    # df_health
    return


@app.cell
def _(df_ownership):
    df_ownership
    return


@app.cell
def _(df_ownership):
    df_ownership.value_counts("owner")
    return


@app.cell
def _(df_ownership):
    df_ownership
    return


@app.cell
def _():
    return


@app.cell
def _(df_ownership):
    df_ownership
    return


@app.cell
def _():
    return


@app.cell
def _(df_health):
    df_health["Created_years"].value_counts()
    return


@app.cell
def _(df_health):
    df_health.groupby(["Created_years", "owner_type"]).count()
    return


@app.cell
def _(df_health):
    df_health[
        (df_health["owner_type"] == "Organization")
        & (df_health["Created_years"] == "2022-2025")
    ]
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    - Todo
    - Eval Frameworks timeline. X axis: time yearly, y axis: number of evaluation framework repos created. Simple bar chart of line chart. Goal is to show uptick in eval tools post 2023.
    - Another graph should show subcat breakdown and uptick in evaluation frameworks since AI boom.
    - HAI engineering line chart (split into MCP vs non-mcp)
    - HAI engineering subcat breakdown
    - Whos building: ownership over time . Stacked chart with segments, big tech vs startups vs individual contributors. Want to hopefully show that big tech dominated the early years. This needs to properly process the data to account for not only creation date but end date. So at each point graph just shows active repos at that point in time.
    """
    )
    return


@app.cell
def _(Who):
    Who
    return


@app.cell(column=1)
def _(mo):
    mo.md(
        r"""
    ## Chart 1. Treemap
    """
    )
    return


@app.cell(hide_code=True)
def _(df_health):
    import plotly.express as px

    df = df_health.copy()
    df = df[~df["Category"].isin(["Archived", "Model repo"])]
    df = df.groupby(["Category", "Subcat"])["Stars"].count().reset_index()

    # Create custom text labels with counts
    df["label"] = df["Subcat"] + "<br>" + df["Stars"].astype(str)

    fig = px.treemap(
        df,
        path=["Category", "Subcat"],
        values="Stars",
        color_continuous_scale="RdBu",
        custom_data=["Stars"],
    )

    # Update text to show both label and count
    fig.update_traces(
        texttemplate="<b>%{label}</b><br>%{customdata[0]}",
        textposition="middle center",
        textfont=dict(size=14, color="white"),
        root_color="rgba(0,0,0,0)",
        marker=dict(line=dict(width=0)),
    )

    fig.show()
    fig.write_image("./nice_plots/treeplot.svg")
    return (px,)


@app.cell
def _(mo):
    mo.md(
        r"""
    ## Chart 2. Interoperability Repo Breakdown
    """
    )
    return


@app.cell(hide_code=True)
def _(df_interop, px):
    subcat_counts = df_interop["Subcat"].value_counts()

    # Calculate percentage for top 2 categories
    top_2_sum = subcat_counts.iloc[:2].sum()
    total = subcat_counts.sum()
    top_2_percentage = (top_2_sum / total) * 100

    fig_subcat = px.bar(
        x=subcat_counts.values,
        y=subcat_counts.index,
        orientation="h",
        title=f"Please Sir, may I have some Data?",
        subtitle="Breakdown of Interoperability Repos",
        labels={"x": "Number of Repositories", "y": "Subcategory"},
        # color=subcat_counts.values,
        # color_continuous_scale='Tealrose'
    )

    # Add values at the end of each bar
    fig_subcat.update_traces(
        text=subcat_counts.values, textposition="outside", textfont=dict(size=12)
    )

    fig_subcat.update_layout(height=500, yaxis={"categoryorder": "total ascending"})

    fig_subcat.update_layout(yaxis_title=None)
    fig_subcat.update_layout(legend=None)
    fig_subcat.update_layout()
    fig_subcat.show()
    fig_subcat.write_image("./nice_plots/interoperability.svg")
    return


@app.cell(column=2)
def _(mo):
    mo.md(
        r"""
    ## Chart 3. Most popular Interoperability Repos
    """
    )
    return


@app.cell(hide_code=True)
def _(df_interop, px):
    # TODO: Add an additional legend for Personal/Organisation

    interop_top_repo_stars = (
        df_interop[["Repository", "Stars", "Subcat"]]
        .sort_values(by="Stars", ascending=False)
        .head(10)
        .set_index("Repository")
        .copy()
    )

    fig_interop_repos = px.bar(
        x=interop_top_repo_stars["Stars"],
        y=interop_top_repo_stars.index,
        orientation="h",
        title=f"Please Sir, may I have some Data?",
        subtitle="Most Popular Interoperability Repos",
        labels={"x": "Number of Repositories", "y": "Subcategory"},
        color=interop_top_repo_stars["Subcat"],
        color_continuous_scale="Teal",
    )

    # Add values at the end of each bar
    fig_interop_repos.update_traces(
        text=interop_top_repo_stars.values,
        textposition="outside",
        textfont=dict(size=12),
    )

    fig_interop_repos.update_layout(
        height=500, yaxis={"categoryorder": "total ascending"}
    )

    fig_interop_repos.update_layout(yaxis_title=None)
    fig_interop_repos.update_layout(legend=None)
    fig_interop_repos.update_layout()
    fig_interop_repos.show()
    fig_interop_repos.write_image("./nice_plots/interoperability_repos.svg")
    return (interop_top_repo_stars,)


@app.cell(hide_code=True)
def _(df_health, px):
    df_model_dev = df_health[df_health["Category"] == "Model Development"]

    _subcat_counts = df_model_dev["Subcat"].value_counts()

    _fig_subcat = px.bar(
        x=_subcat_counts.values,
        y=_subcat_counts.index,
        orientation="h",
        title=f"D'ya like models?",
        subtitle="Breakdown of Model Development Repos",
        labels={"x": "Number of Repositories", "y": "Subcategory"},
        # color=_subcat_counts.values,
        # color_continuous_scale='Teal'
    )

    # Add values at the end of each bar
    _fig_subcat.update_traces(
        text=_subcat_counts.values, textposition="outside", textfont=dict(size=12)
    )

    _fig_subcat.update_layout(height=500, yaxis={"categoryorder": "total ascending"})

    _fig_subcat.update_layout(yaxis_title=None)
    _fig_subcat.update_layout(legend=None)
    _fig_subcat.update_layout()
    _fig_subcat.show()
    _fig_subcat.write_image("./nice_plots/model_development.svg")
    return


@app.cell
def _():
    return


if __name__ == "__main__":
    app.run()
