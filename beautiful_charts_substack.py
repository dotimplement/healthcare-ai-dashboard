import marimo

__generated_with = "0.17.8"
app = marimo.App(width="columns")


@app.cell(column=0)
def _():
    import marimo as mo
    import pandas as pd
    from datetime import datetime, timedelta
    import numpy as np
    import plotly.express as px

    return datetime, mo, np, pd, px, timedelta


@app.cell(hide_code=True)
def _(datetime, np, pd, timedelta):
    def load_and_process_data():
        """Load and process the healthcare repository data"""
        df = pd.read_csv("healthcare_data.csv")

        # Remove unimportant categories
        df = df[
            ~df["Category"].isin(
                [
                    "Lists",
                    "Tutorials",
                    "Specification / Docs",
                    "Archived / Deprecated",
                    "Educational",
                ]
            )
        ]

        # Convert to datetime
        df["Created"] = pd.to_datetime(df["Created"])
        df["Last Commit"] = pd.to_datetime(df["Last Commit"])

        # Create new columns
        today = datetime.now()
        df["days_since_last_commit"] = (today - df["Last Commit"]).apply(
            lambda x: x.days
        )
        df["contributor_count"] = (
            df["Top Contributors"].fillna("").str.split(",").apply(len)
        )
        df["Org"] = df["Repository"].str.split("/").str[0]

        # Active definition: committed within last 365 days
        df["recent_activity_category"] = np.where(
            df["days_since_last_commit"] < 365, "Active", "Inactive"
        )

        # Additional processing for visualizations
        df["first_commit"] = df["Created"]
        df["last_commit"] = df["Last Commit"]
        df["lifespan_days"] = (df["last_commit"] - df["first_commit"]).dt.days
        df["start_year"] = df["first_commit"].dt.year
        df["is_active"] = df["last_commit"] >= (today - timedelta(days=365))

        # Process Standard column - handle multiple standards
        df["Standard"] = df["Standard"].fillna("None/Unknown")
        df["has_standard"] = df["Standard"] != "None/Unknown"

        # Create exploded dataframe for multi-standard analysis
        df["standards_list"] = df["Standard"].apply(
            lambda x: [s.strip() for s in str(x).split(",") if s.strip()]
        )

        # Load the classified repos CSV (generated by the GitHub classifier script)
        classified_df = pd.read_csv("repos_classified.csv")

        # Create a mapping dictionary from owner to organization status
        owner_classification = (
            classified_df.drop_duplicates(subset=["owner"])
            .set_index("owner")[["is_organization", "owner_type"]]
            .to_dict("index")
        )

        # Apply the classification to your main dataframe
        df["is_organization"] = df["Org"].map(
            lambda x: owner_classification.get(x, {}).get("is_organization", None)
        )
        df["owner_type"] = df["Org"].map(
            lambda x: owner_classification.get(x, {}).get("owner_type", "Unknown")
        )

        df["Created_years"] = "Upto 2016"

        df.loc[df["Created"].dt.year >= 2016, "Created_years"] = "2016-2018"
        df.loc[df["Created"].dt.year >= 2019, "Created_years"] = "2019-2021"
        df.loc[df["Created"].dt.year >= 2022, "Created_years"] = "2022-2025"

        mylist = [
            "epic",
            "Google",
            "apple",
            "hapi",
            "Firely",
            "microsoft",
            "awslabs",
            "google",
            "nextgen",
            "b2ihealth",
        ]
        pattern = "|".join(mylist)

        # Set 'owner type' to 'Research Lab' for matching repositories
        df.loc[
            df["Repository"].str.contains(pattern, case=False, na=False), "owner_type"
        ] = "Incumbent"

        mylist = [
            "tanford",
            "MIT",
            "complab",
            "sunlab",
            "ncbi",
            "islab",
            "ZhiGroup",
            "bowang",
            "NYU",
            "shahlab",
            "aiwong",
            "uf-hobi-informatics-lab",
            "MONAI",
            "Fudan",
            "healthylaife",
            "biosensing",
        ]
        pattern = "|".join(mylist)

        # Set 'owner type' to 'Research Lab' for matching repositories
        df.loc[
            df["Repository"].str.contains(pattern, case=False, na=False), "owner_type"
        ] = "Research Lab"

        mylist = [
            "synthetichealth",
            "medplum",
            "metriport",
            "bluehalo",
            "implement",
            "fastenhealth",
            "earthians",
            "fhirbase",
            "CogStack",
            "owkin",
            "beda-",
            "Vermonster",
            "masslight",
        ]
        pattern = "|".join(mylist)

        # Set 'owner type' to 'Research Lab' for matching repositories
        df.loc[
            df["Repository"].str.contains(pattern, case=False, na=False), "owner_type"
        ] = "Startup"

        mylist = [
            "openemr",
            "openmrs",
            "HospitalRun",
            "informatici",
            "OHDSI",
            "smart",
            "HL7",
            "Linux",
            "FHIR/",
            "cqframe",
            "analysisce",
            "LibreHealth",
            "oehf",
            "cds-hooks",
            "BiomedSci",
            "fhir-crucible",
            "samply",
            "mne-tools",
            "inferno-framework",
            "HealthIntersections",
        ]
        pattern = "|".join(mylist)

        # Set 'owner type' to 'Research Lab' for matching repositories
        df.loc[
            df["Repository"].str.contains(pattern, case=False, na=False), "owner_type"
        ] = "Community Project/Non-Profit"

        mylist = ["node-on-fhir", "ehrbase", "OpenHealthForAll"]
        pattern = "|".join(mylist)

        # Set 'owner type' to 'Research Lab' for matching repositories
        df.loc[
            df["Repository"].str.contains(pattern, case=False, na=False), "owner_type"
        ] = "User"

        return df

    return (load_and_process_data,)


@app.cell
def _(load_and_process_data):
    df_health = load_and_process_data()
    return (df_health,)


@app.cell
def _(df_health):
    df_interop = df_health[df_health["Category"] == "Interoperability"]
    return (df_interop,)


@app.cell
def _(pd):
    df_ownership = pd.read_csv("./repos_classified.csv")
    return (df_ownership,)


@app.cell
def _(df_ownership, interop_top_repo_stars):
    df_ownership[df_ownership["full_name"].isin(list(interop_top_repo_stars.index))]
    return


@app.cell
def _():
    ## Time series of languages over time
    return


@app.cell
def _(px):
    color_palette = px.colors.qualitative.Set2
    return (color_palette,)


@app.cell
def _():
    ## Time series of subcats over time
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    ## Breakdown of HAI Repos
    """
    )
    return


@app.cell
def _():
    # TODO: Either make this into a simple time series or keep bar chart
    return


@app.cell
def _():
    # df_health
    return


@app.cell
def _(df_ownership):
    df_ownership
    return


@app.cell
def _(df_ownership):
    df_ownership.value_counts("owner")
    return


@app.cell
def _(df_ownership):
    df_ownership
    return


@app.cell
def _():
    return


@app.cell
def _(df_ownership):
    df_ownership
    return


@app.cell
def _():
    return


@app.cell
def _(df_health):
    df_health["Created_years"].value_counts()
    return


@app.cell
def _(df_health):
    df_health.groupby(["Created_years", "owner_type"]).count()
    return


@app.cell
def _(df_health):
    df_health[
        (df_health["owner_type"] == "Organization")
        & (df_health["Created_years"] == "2022-2025")
    ]
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    - Todo
    - Eval Frameworks timeline. X axis: time yearly, y axis: number of evaluation framework repos created. Simple bar chart of line chart. Goal is to show uptick in eval tools post 2023.
    - Another graph should show subcat breakdown and uptick in evaluation frameworks since AI boom.
    - HAI engineering line chart (split into MCP vs non-mcp)
    - HAI engineering subcat breakdown
    - Whos building: ownership over time . Stacked chart with segments, big tech vs startups vs individual contributors. Want to hopefully show that big tech dominated the early years. This needs to properly process the data to account for not only creation date but end date. So at each point graph just shows active repos at that point in time.
    """
    )
    return


@app.cell(column=1)
def _(mo):
    mo.md(
        r"""
    ## Chart 1. Treemap
    """
    )
    return


@app.cell(hide_code=True)
def _(color_palette, df_health, px):
    df = df_health.copy()
    df = df[~df["Category"].isin(["Archived", "Model repo"])]
    df = df.groupby(["Category", "Subcat"])["Stars"].count().reset_index()

    # Create custom text labels with counts
    df["label"] = df["Subcat"] + "<br>" + df["Stars"].astype(str)

    fig = px.treemap(
        df,
        path=["Category", "Subcat"],
        values="Stars",
        color_continuous_scale=color_palette,
        custom_data=["Stars"],
    )

    # Update text to show both label and count
    fig.update_traces(
        texttemplate="<b>%{label}</b><br>%{customdata[0]}",
        textposition="middle center",
        textfont=dict(size=16, color="white"),
        root_color="rgba(0,0,0,0)",
        marker=dict(line=dict(width=0)),
    )

    # Make the figure larger
    fig.update_layout(
        width=1000,  # Width in pixels (default is usually 700)
        height=700,  # Height in pixels (default is usually 450)
        template="plotly_white",
    )

    # fig.show()
    fig.write_image("./nice_plots/treeplot.png")
    return


@app.cell
def _(mo):
    mo.md(
        r"""
    ## Chart 2. Interoperability Repo Breakdown
    """
    )
    return


@app.cell(hide_code=True)
def _(color_palette, df_interop, go):
    # Prepare data for left chart (subcategory counts)
    subcat_counts = df_interop["Subcat"].value_counts()

    # Prepare data for right chart (top repos)
    interop_top_repo_stars = (
        df_interop[["Repository", "Stars", "Subcat"]]
        .sort_values(by="Stars", ascending=False)
        .head(10)
        .set_index("Repository")
        .copy()
    )

    # LEFT CHART: Subcategory counts
    _fig1 = go.Figure()
    _fig1.add_trace(
        go.Bar(
            x=subcat_counts.values,
            y=subcat_counts.index,
            orientation="h",
            marker_color=color_palette[0],
            text=subcat_counts.values,
            textposition="inside",
            textfont=dict(size=12),
            showlegend=False,
        )
    )
    _fig1.update_xaxes(title_text="Number of Repositories", automargin=True)
    _fig1.update_yaxes(categoryorder="total ascending", automargin=True)
    _fig1.update_layout(
        title_text="Breakdown of Interoperability Repos",
        template="plotly_white",
        height=500,
        width=700,
        autosize=True,
    )
    _fig1.show()
    _fig1.write_image("./nice_plots/interoperability_breakdown.png")

    # RIGHT CHART: Top repos by stars (colored by subcategory)
    _fig2 = go.Figure()
    subcats_in_top = interop_top_repo_stars["Subcat"].unique()
    subcat_color_map = {
        subcat: color_palette[i % len(color_palette)]
        for i, subcat in enumerate(sorted(df_interop["Subcat"].unique()))
    }

    for subcat in subcats_in_top:
        subcat_data = interop_top_repo_stars[interop_top_repo_stars["Subcat"] == subcat]
        _fig2.add_trace(
            go.Bar(
                x=subcat_data["Stars"],
                y=subcat_data.index,
                orientation="h",
                name=subcat,
                text=subcat_data["Stars"].values,
                marker_color=subcat_color_map[subcat],
                textposition="inside",
                textfont=dict(size=12),
                legendgroup=subcat,
                showlegend=True,
            )
        )

    _fig2.update_xaxes(title_text="Number of Stars", automargin=True)
    _fig2.update_yaxes(categoryorder="total ascending", automargin=True)
    _fig2.update_layout(
        title_text="Top 10 Interoperability Repos",
        template="plotly_white",
        height=500,
        width=700,
        showlegend=True,
        legend=dict(
            title=dict(text="Subcat"),
            orientation="v",
            yanchor="top",
            y=1,
            xanchor="left",
            x=1.02,
        ),
        autosize=True,
    )
    _fig2.show()
    _fig2.write_image("./nice_plots/interoperability_top_repos.png")

    return interop_top_repo_stars, subcat_counts


@app.cell(hide_code=True)
def _(color_palette, df_health, px):
    # Count the combinations
    counts = (
        df_health.groupby(["owner_type", "Category"]).size().reset_index(name="count")
    )

    # Create the grouped bar chart
    _fig = px.bar(
        counts,
        x="owner_type",
        y="count",
        color="Category",
        color_discrete_sequence=color_palette,
        title="Count by Owner Type and Category",
        labels={"count": "Number of Rows", "owner_type": "Owner Type"},
        barmode="group",
        template="plotly_white",
    )  # This creates grouped bars side-by-side

    # _fig.show()
    return


@app.cell
def _(color_palette, df_model_dev, go, subcat_counts):
    # Prepare data for left chart (subcategory counts)
    _subcat_counts = df_model_dev["Subcat"].value_counts()

    # Prepare data for right chart (top repos)
    md_top_repo_stars = (
        df_model_dev[["Repository", "Stars", "Subcat"]]
        .sort_values(by="Stars", ascending=False)
        .head(10)
        .set_index("Repository")
        .copy()
    )

    # LEFT CHART: Subcategory counts
    _fig1 = go.Figure()
    _fig1.add_trace(
        go.Bar(
            x=_subcat_counts.values,
            y=_subcat_counts.index,
            orientation="h",
            marker_color=color_palette[0],
            text=subcat_counts.values,
            textposition="inside",
            textfont=dict(size=12),
            showlegend=False,
        )
    )
    _fig1.update_xaxes(title_text="Number of Repositories", automargin=True)
    _fig1.update_yaxes(categoryorder="total ascending", automargin=True)
    _fig1.update_layout(
        title_text="Breakdown of Model Development Repos",
        template="plotly_white",
        height=500,
        width=700,
        autosize=True,
    )
    _fig1.show()
    _fig1.write_image("./nice_plots/model_development_breakdown.png")

    # RIGHT CHART: Top repos by stars (colored by subcategory)
    _fig2 = go.Figure()
    _subcats_in_top = md_top_repo_stars["Subcat"].unique()
    _subcat_color_map = {
        subcat: color_palette[i % len(color_palette)]
        for i, subcat in enumerate(sorted(df_model_dev["Subcat"].unique()))
    }

    for _subcat in _subcats_in_top:
        _subcat_data = md_top_repo_stars[md_top_repo_stars["Subcat"] == _subcat]
        _fig2.add_trace(
            go.Bar(
                x=_subcat_data["Stars"],
                y=_subcat_data.index,
                orientation="h",
                name=_subcat,
                text=_subcat_data["Stars"].values,
                marker_color=_subcat_color_map[_subcat],
                textposition="inside",
                textfont=dict(size=12),
                legendgroup=_subcat,
                showlegend=True,
            )
        )

    _fig2.update_xaxes(title_text="Number of Stars", automargin=True)
    _fig2.update_yaxes(categoryorder="total ascending", automargin=True)
    _fig2.update_layout(
        title_text="Top 10 Model Development Repos",
        template="plotly_white",
        height=500,
        width=700,
        showlegend=True,
        legend=dict(
            title=dict(text="Subcat"),
            orientation="v",
            yanchor="top",
            y=1,
            xanchor="left",
            x=1.02,
        ),
        autosize=True,
    )
    _fig2.show()
    _fig2.write_image("./nice_plots/model_development_top_repos.png")
    return


@app.cell
def _(color_palette, df_health, go):
    def plot_repos_by_owner_type_periods(repos_df):
        """
        Create a stacked bar chart showing repository counts by owner_type for three time periods.
        Args:
            repos_df: DataFrame with columns ['date_created', 'owner_type']
        """
        repos_df = repos_df.copy()

        # Filter data
        repos_df = repos_df[
            repos_df["owner_type"].isin(
                ["Research Lab", "Community Project/Non-Profit", "Startup", "Incumbent"]
            )
        ]

        repos_df["year"] = repos_df["Created"].dt.year
        repos_df = repos_df[(repos_df["year"] >= 2020) & (repos_df["year"] < 2026)]

        # Create year groups
        def group_years(year):
            if year in [2017, 2018, 2019]:
                return "2017-19"
            elif year in [2020, 2021, 2022]:
                return "2020-22"
            elif year in [2023, 2024, 2025]:
                return "2023-25"
            return str(year)

        repos_df["year_group"] = repos_df["year"].apply(group_years)

        # Count repos by year_group and owner_type
        period_data = (
            repos_df.groupby(["year_group", "owner_type"])
            .size()
            .reset_index(name="count")
        )

        # Get unique owner types and assign colors
        owner_types = sorted(period_data["owner_type"].unique())
        # color_palette = px.colors.qualitative.Set2
        colors = {
            owner_type: color_palette[i % len(color_palette)]
            for i, owner_type in enumerate(owner_types)
        }

        # Create figure
        fig = go.Figure()

        year_order = ["2017-19", "2020-22", "2023-25"]

        for owner_type in owner_types:
            owner_data = period_data[period_data["owner_type"] == owner_type]

            fig.add_trace(
                go.Bar(
                    x=owner_data["year_group"],
                    y=owner_data["count"],
                    name=owner_type.capitalize(),
                    marker_color=colors[owner_type],
                )
            )

        fig.update_layout(
            title="Repository Creation by Owner Type",
            xaxis_title="Year Period",
            yaxis_title="Number of Repositories",
            barmode="stack",
            template="plotly_white",
            height=500,
            width=800,
            xaxis=dict(categoryorder="array", categoryarray=year_order),
            legend=dict(title=dict(text="Owner Type")),
        )

        return fig

    # Example usage:
    _fig = plot_repos_by_owner_type_periods(df_health)
    _fig.show()
    _fig.write_image("./nice_plots/repo_creation_by_owner_type.png")
    return


@app.cell
def _(color_palette, df_health):
    def plot_hai_engineering_timeline(repos_df, category_col="category"):
        """
        Create a time series chart of HAI Engineering repository creation over time.
        Args:
            repos_df: DataFrame with columns ['date_created', category_col]
            category_col: Name of the category column
        """
        import plotly.graph_objects as go
        import plotly.express as px

        # Filter to HAI Engineering category
        hai_df = repos_df[repos_df[category_col] == "HAI engineering"].copy()
        hai_df = hai_df.sort_values("Created")

        # Create figure
        fig = go.Figure()

        # Time series of repo creation
        hai_df["year"] = hai_df["Created"].dt.year
        yearly_counts = hai_df.groupby("year").size().reset_index(name="count")

        # Get all years for tick values
        all_years = sorted(yearly_counts["year"].unique())

        fig.add_trace(
            go.Scatter(
                x=yearly_counts["year"],
                y=yearly_counts["count"],
                mode="lines+markers",
                line=dict(width=3, color=px.colors.qualitative.Set2[0]),
                marker=dict(size=8, color=px.colors.qualitative.Set2[0]),
                showlegend=False,
            )
        )

        # Update axes and layout
        fig.update_xaxes(
            title_text="Year",
            tickmode="array",
            tickvals=all_years,
            ticktext=[str(year) for year in all_years],
        )
        fig.update_yaxes(title_text="Number of Repositories")

        fig.update_layout(
            title_text="HAI Engineering Repository Creation Over Time",
            template="plotly_white",
            height=400,
            width=800,
        )

        return fig

    def plot_hai_engineering_breakdown(
        repos_df, category_col="category", subcat_col="subcat"
    ):
        """
        Create a horizontal bar chart of HAI Engineering subcategory breakdown.
        Args:
            repos_df: DataFrame with columns [category_col, subcat_col]
            category_col: Name of the category column
            subcat_col: Name of the subcategory column
        """
        import plotly.graph_objects as go

        # Filter to HAI Engineering category
        hai_df = repos_df[repos_df[category_col] == "HAI engineering"].copy()

        # Create figure
        fig = go.Figure()

        # Horizontal bar chart of subcategories
        subcat_counts = hai_df[subcat_col].value_counts()

        fig.add_trace(
            go.Bar(
                x=subcat_counts.values,
                y=subcat_counts.index,
                orientation="h",
                marker_color=color_palette[0],
                text=subcat_counts.values,
                textposition="outside",
                textfont=dict(size=12),
                showlegend=False,
            )
        )

        # Update axes and layout
        fig.update_xaxes(title_text="Number of Repositories", automargin=True)
        fig.update_yaxes(categoryorder="total ascending", automargin=True)

        fig.update_layout(
            title_text="HAI Engineering Subcategory Breakdown",
            template="plotly_white",
            height=400,
            width=800,
        )

        return fig

    # Create both charts
    _fig1 = plot_hai_engineering_timeline(df_health, category_col="Category")
    _fig1.write_image("./nice_plots/hai_engineering_timeline.png")

    _fig2 = plot_hai_engineering_breakdown(
        df_health, category_col="Category", subcat_col="Subcat"
    )
    _fig2.write_image("./nice_plots/hai_engineering_breakdown.png")
    return


@app.cell
def _():
    return


@app.cell(column=2)
def _(mo):
    mo.md(
        r"""
    ## Chart 3. Most popular Interoperability Repos
    """
    )
    return


@app.cell(hide_code=True)
def _():
    # TODO: Add an additional legend for Personal/Organisation

    return


@app.cell(hide_code=True)
def _(color_palette, df_health, px):
    df_model_dev = df_health[df_health["Category"] == "Model Development"]

    _subcat_counts = df_model_dev["Subcat"].value_counts()

    _fig_subcat = px.bar(
        x=_subcat_counts.values,
        y=_subcat_counts.index,
        orientation="h",
        title=f"D'ya like models?",
        subtitle="Breakdown of Model Development Repos",
        labels={"x": "Number of Repositories", "y": "Subcategory"},
        # color=_subcat_counts.values,
        # color_continuous_scale='Teal'
        color_discrete_sequence=color_palette,
        template="plotly_white",
    )

    # Add values at the end of each bar
    _fig_subcat.update_traces(
        text=_subcat_counts.values, textposition="outside", textfont=dict(size=12)
    )

    _fig_subcat.update_layout(height=500, yaxis={"categoryorder": "total ascending"})

    _fig_subcat.update_layout(yaxis_title=None)
    _fig_subcat.update_layout(legend=None)
    _fig_subcat.update_layout()
    _fig_subcat.show()
    _fig_subcat.update_xaxes(automargin=True)
    _fig_subcat.update_yaxes(automargin=True)
    _fig_subcat.update_layout(
        # margin=dict(l=0, r=0, t=30, b=0),
        autosize=True
    )
    _fig_subcat.write_image("./nice_plots/model_development.png")
    return (df_model_dev,)


@app.cell(hide_code=True)
def _(pd, timedelta):
    import plotly.graph_objects as go

    import requests

    from time import sleep
    from tqdm import tqdm

    # GitHub API Configuration
    # GITHUB_TOKEN = 'your_github_token_here'  # Replace with your token
    PLOT_TYPE = "stars"  # Options: 'count' or 'stars'

    def get_star_history(owner, repo, token):
        """
        Fetch complete star history for a GitHub repository.
        Returns a list of dicts with 'starred_at' timestamps.
        """
        stars = []
        page = 1

        headers = {
            "Accept": "application/vnd.github.v3.star+json",
            "Authorization": f"token {token}",
        }

        while True:
            url = f"https://api.github.com/repos/{owner}/{repo}/stargazers"
            params = {"per_page": 100, "page": page}

            response = requests.get(url, headers=headers, params=params)

            if response.status_code == 403:  # Rate limit
                print(f"Rate limit hit for {owner}/{repo}. Waiting...")
                sleep(60)
                continue
            elif response.status_code != 200:
                print(f"Error fetching {owner}/{repo}: {response.status_code}")
                break

            data = response.json()
            if not data:
                break

            stars.extend(data)
            page += 1

            # Small delay to avoid rate limiting
            sleep(0.1)

        return stars

    def process_star_history(df_health, token):
        """
        Process repositories and fetch their star histories.
        Returns a dataframe with time-series star events.
        """
        df_ts = df_health.copy()
        df_ts = df_ts[df_ts["owner_type"] != "Unknown"]
        df_ts = df_ts[
            df_ts["Category"].isin(
                [
                    "Interoperability",
                    "Infrastructure",
                    "Model Development",
                    "HAI Engineering",
                    "Archived",
                ]
            )
        ]
        df_ts = df_ts.sort_values(by="Stars", ascending=False).head(100)

        # Calculate the "active until" date
        df_ts["active_until"] = df_ts["Last Commit"] + timedelta(days=365)

        # Create events for star history
        star_events = []

        print("Fetching star histories from GitHub API...")
        for _, row in tqdm(df_ts.iterrows(), total=len(df_ts)):
            repo_full_name = row["Repository"]

            # Parse owner/repo from full name
            if "/" in repo_full_name:
                owner, repo = repo_full_name.split("/", 1)
            else:
                print(f"Skipping invalid repo name: {repo_full_name}")
                continue

            # Fetch star history from API
            star_history = get_star_history(owner, repo, token)

            if not star_history:
                print(f"No star history for {repo_full_name}")
                continue

            # Create events for each star
            for star in star_history:
                starred_at = pd.to_datetime(star["starred_at"])

                # Only count star if repo was active at that time
                if starred_at.tz_localize(None) >= row["Created"].tz_localize(None):
                    # Add star event
                    star_events.append(
                        {
                            "date": starred_at.tz_localize(None),
                            "change": 1,
                            "repo": repo_full_name,
                            "owner_type": row["owner_type"],
                            "event_type": "star_gained",
                        }
                    )

                    # Add corresponding "remove star" event when repo becomes inactive
                    # (if star was gained before repo became inactive)
                    if starred_at.tz_localize(None) < row["active_until"].tz_localize(
                        None
                    ):
                        star_events.append(
                            {
                                "date": row["active_until"].tz_localize(None),
                                "change": -1,
                                "repo": repo_full_name,
                                "owner_type": row["owner_type"],
                                "event_type": "star_removed_inactive",
                            }
                        )

        return pd.DataFrame(star_events)

    def plot_star_history(events_df):
        """
        Create an interactive Plotly chart of star history over time.
        """
        events_df = events_df[
            events_df["owner_type"].isin(
                ["Research Lab", "Community Project/Non-Profit", "Startup", "Incumbent"]
            )
        ]
        # Sort by date
        events_df = events_df.sort_values("date")

        # Get unique owner types
        owner_types = events_df["owner_type"].unique()

        # Create the plot
        fig = go.Figure()

        # Generate colors
        import plotly.express as px

        color_palette = px.colors.qualitative.Set2
        colors = {
            owner_type: color_palette[i % len(color_palette)]
            for i, owner_type in enumerate(sorted(owner_types))
        }

        for owner_type in owner_types:
            mask = events_df["owner_type"] == owner_type
            owner_events = events_df[mask].copy()
            owner_events["cumulative"] = owner_events["change"].cumsum()

            # Resample to monthly
            owner_events = (
                owner_events.set_index("date")["cumulative"]
                .resample("M")
                .last()
                .ffill()
                .reset_index()
            )
            owner_events = owner_events[owner_events["date"] < "2025-10-01"]

            color = colors[owner_type]

            fig.add_trace(
                go.Scatter(
                    x=owner_events["date"],
                    y=owner_events["cumulative"],
                    mode="lines",
                    name=owner_type.capitalize(),
                    line=dict(width=2, color=color),
                )
            )

        fig.update_layout(
            title="GitHub Stars in Active Repositories Over Time (Historical)",
            xaxis_title="Date",
            yaxis_title="Total Stars in Active Repositories",
            hovermode="x unified",
            template="plotly_white",
            height=500,
        )

        return fig

    def plot_star_history_bar(events_df):
        """
        Create an interactive Plotly bar chart of yearly star contributions by category.
        """
        events_df = events_df[
            events_df["owner_type"].isin(
                ["Research Lab", "Community Project/Non-Profit", "Startup", "Incumbent"]
            )
        ]
        events_df = events_df[events_df["change"] > 0]
        # Sort by date
        events_df = events_df.sort_values("date")

        # Extract year
        events_df["year"] = events_df["date"].dt.year

        # Filter out 2025 (partial year)
        events_df = events_df[events_df["year"] < 2026]

        # Get unique owner types
        owner_types = events_df["owner_type"].unique()

        # Generate colors
        import plotly.express as px

        color_palette = px.colors.qualitative.Set2
        colors = {
            owner_type: color_palette[i % len(color_palette)]
            for i, owner_type in enumerate(sorted(owner_types))
        }

        # Create the plot
        fig = go.Figure()

        # Group by year and owner_type, sum the changes
        yearly_data = (
            events_df.groupby(["year", "owner_type"])["change"].sum().reset_index()
        )

        for owner_type in sorted(owner_types):
            owner_data = yearly_data[yearly_data["owner_type"] == owner_type]
            color = colors[owner_type]

            fig.add_trace(
                go.Bar(
                    x=owner_data["year"],
                    y=owner_data["change"],
                    name=owner_type.capitalize(),
                    marker_color=color,
                )
            )

        fig.update_layout(
            title="Yearly GitHub Star Contributions by Category",
            xaxis_title="Year",
            yaxis_title="Stars Added",
            hovermode="x unified",
            template="plotly_white",
            height=500,
            barmode="stack",  # Stacked bars to show contribution to total
            xaxis=dict(type="category"),  # Treat years as categories for better spacing
        )

        return fig

    def plot_star_history_unstack_bar(events_df):
        """
        Create an interactive Plotly bar chart of yearly star contributions by category (as percentages).
        """
        events_df = events_df[
            events_df["owner_type"].isin(
                ["Research Lab", "Community Project/Non-Profit", "Startup", "Incumbent"]
            )
        ]
        events_df = events_df[events_df["change"] > 0]
        # Sort by date
        events_df = events_df.sort_values("date")

        # Extract year
        events_df["year"] = events_df["date"].dt.year

        # Filter out years before 2020 and after 2025
        events_df = events_df[(events_df["year"] >= 2020) & (events_df["year"] < 2026)]

        # Create year groups
        def group_years(year):
            # if year in [2017, 2018, 2019]:
            #     return '2017-19'
            if year in [2020, 2021, 2022]:
                return "2020-22"
            elif year in [2023, 2024, 2025]:
                return "2023-25"
            return str(year)

        events_df["year_group"] = events_df["year"].apply(group_years)

        # Get unique owner types
        owner_types = events_df["owner_type"].unique()

        # Generate colors
        import plotly.express as px

        color_palette = px.colors.qualitative.Set2
        colors = {
            owner_type: color_palette[i % len(color_palette)]
            for i, owner_type in enumerate(sorted(owner_types))
        }

        # Create the plot
        fig = go.Figure()

        # Group by year_group and owner_type, sum the changes
        yearly_data = (
            events_df.groupby(["year_group", "owner_type"])["change"]
            .sum()
            .reset_index()
        )

        # Calculate yearly totals
        yearly_totals = yearly_data.groupby("year_group")["change"].sum().reset_index()
        yearly_totals.columns = ["year_group", "total"]

        # Merge totals back and calculate percentages
        yearly_data = yearly_data.merge(yearly_totals, on="year_group")
        yearly_data["percentage"] = (yearly_data["change"] / yearly_data["total"]) * 100

        # Define order for x-axis
        year_order = ["2020/21", "2022/23", "2024/25"]

        for owner_type in sorted(owner_types):
            owner_data = yearly_data[yearly_data["owner_type"] == owner_type]
            color = colors[owner_type]

            fig.add_trace(
                go.Bar(
                    x=owner_data["year_group"],
                    y=owner_data["percentage"],
                    name=owner_type.capitalize(),
                    marker_color=color,
                )
            )

        fig.update_layout(
            title="GitHub Star Contributions by Category (Percentage)",
            xaxis_title="Year Period",
            yaxis_title="Percentage of Period Stars (%)",
            hovermode="x unified",
            template="plotly_white",
            height=500,
            barmode="group",  # Grouped bars side-by-side
            xaxis=dict(
                type="category",
                categoryorder="array",
                categoryarray=year_order,  # Ensure correct order
            ),
        )

        return fig

    def plot_star_history_line_gradient(events_df):
        """
        Create an interactive Plotly line chart showing the gradient of category contributions
        between two time periods.
        """
        events_df = events_df[
            events_df["owner_type"].isin(
                ["Research Lab", "Community Project/Non-Profit", "Startup", "Incumbent"]
            )
        ]
        events_df = events_df[events_df["change"] > 0]
        # Sort by date
        events_df = events_df.sort_values("date")

        # Extract year
        events_df["year"] = events_df["date"].dt.year

        # Filter out years before 2020 and after 2025
        events_df = events_df[(events_df["year"] >= 2020) & (events_df["year"] < 2026)]

        # Create year groups
        def group_years(year):
            if year in [2020, 2021, 2022]:
                return "2020-22"
            elif year in [2023, 2024, 2025]:
                return "2023-25"
            return str(year)

        events_df["year_group"] = events_df["year"].apply(group_years)

        # Get unique owner types
        owner_types = events_df["owner_type"].unique()

        # Generate colors
        import plotly.express as px

        color_palette = px.colors.qualitative.Set2
        colors = {
            owner_type: color_palette[i % len(color_palette)]
            for i, owner_type in enumerate(sorted(owner_types))
        }

        # Create the plot
        fig = go.Figure()

        # Group by year_group and owner_type, sum the changes
        yearly_data = (
            events_df.groupby(["year_group", "owner_type"])["change"]
            .sum()
            .reset_index()
        )

        # Calculate yearly totals
        yearly_totals = yearly_data.groupby("year_group")["change"].sum().reset_index()
        yearly_totals.columns = ["year_group", "total"]

        # Merge totals back and calculate percentages
        yearly_data = yearly_data.merge(yearly_totals, on="year_group")
        yearly_data["percentage"] = (yearly_data["change"] / yearly_data["total"]) * 100

        # Define order for x-axis
        year_order = ["2020-22", "2023-25"]

        for owner_type in sorted(owner_types):
            owner_data = yearly_data[yearly_data["owner_type"] == owner_type]
            color = colors[owner_type]

            # Sort to ensure correct order
            owner_data = owner_data.sort_values("year_group")

            fig.add_trace(
                go.Scatter(
                    x=owner_data["year_group"],
                    y=owner_data["percentage"],
                    name=owner_type.capitalize(),
                    mode="lines+markers",
                    line=dict(width=4, color=color),
                    marker=dict(size=12, color=color),
                )
            )

            fig.update_layout(
                title="GitHub Star Contributions by Category",
                xaxis_title="Year Period",
                yaxis_title="Percentage of Period Stars (%)",
                hovermode="x unified",
                template="plotly_white",
                height=500,
                font=dict(size=16),  # Global font size
                title_font=dict(size=20),  # Title font size
                xaxis=dict(
                    type="category",
                    categoryorder="array",
                    categoryarray=year_order,
                    range=[-0.3, 1.3],
                    title_font=dict(size=18),  # X-axis title font size
                    tickfont=dict(size=16),  # X-axis tick labels font size
                ),
                yaxis=dict(
                    title_font=dict(size=18),  # Y-axis title font size
                    tickfont=dict(size=16),  # Y-axis tick labels font size
                ),
                legend=dict(font=dict(size=16)),  # Legend font size
            )

        return fig

    def plot_star_history_bar(events_df):
        """
        Create a grouped bar chart of star contributions by percentage.
        """
        import plotly.graph_objects as go
        import plotly.express as px

        # Filter data
        events_df = events_df[
            events_df["owner_type"].isin(
                ["Research Lab", "Community Project/Non-Profit", "Startup", "Incumbent"]
            )
        ]
        events_df = events_df[events_df["change"] > 0]
        events_df = events_df.sort_values("date")
        events_df["year"] = events_df["date"].dt.year
        events_df = events_df[(events_df["year"] >= 2020) & (events_df["year"] < 2026)]

        # Create year groups
        def group_years(year):
            if year in [2020, 2021, 2022]:
                return "2020-22"
            elif year in [2023, 2024, 2025]:
                return "2023-25"
            return str(year)

        events_df["year_group"] = events_df["year"].apply(group_years)

        # Get unique owner types and colors
        owner_types = events_df["owner_type"].unique()
        color_palette = px.colors.qualitative.Set2
        colors = {
            owner_type: color_palette[i % len(color_palette)]
            for i, owner_type in enumerate(sorted(owner_types))
        }

        # Create figure
        fig = go.Figure()

        # Prepare data
        yearly_data = (
            events_df.groupby(["year_group", "owner_type"])["change"]
            .sum()
            .reset_index()
        )

        yearly_totals = yearly_data.groupby("year_group")["change"].sum().reset_index()
        yearly_totals.columns = ["year_group", "total"]

        yearly_data = yearly_data.merge(yearly_totals, on="year_group")
        yearly_data["percentage"] = (yearly_data["change"] / yearly_data["total"]) * 100

        year_order = ["2020-22", "2023-25"]

        # Grouped bar chart
        for owner_type in sorted(owner_types):
            owner_data = yearly_data[yearly_data["owner_type"] == owner_type]
            color = colors[owner_type]

            fig.add_trace(
                go.Bar(
                    x=owner_data["year_group"],
                    y=owner_data["percentage"],
                    name=owner_type.capitalize(),
                    marker_color=color,
                    legendgroup=owner_type,
                    showlegend=True,
                )
            )

        # Update axes and layout
        fig.update_xaxes(
            title_text="Year Period",
            type="category",
            categoryorder="array",
            categoryarray=year_order,
            title_font=dict(size=18),
            tickfont=dict(size=16),
        )

        fig.update_yaxes(
            title_text="Percentage (%)",
            title_font=dict(size=18),
            tickfont=dict(size=16),
        )

        fig.update_layout(
            title_text="Star Contributions by Period (%)",
            hovermode="x unified",
            template="plotly_white",
            height=500,
            width=700,
            font=dict(size=16),
            title_font=dict(size=20),
            legend=dict(
                orientation="v",
                yanchor="top",
                y=1,
                xanchor="left",
                x=1.02,
                font=dict(size=16),
            ),
        )

        return fig

    def plot_star_history_trend(events_df):
        """
        Create a line chart showing the trend between periods.
        """
        import plotly.graph_objects as go
        import plotly.express as px

        # Filter data
        events_df = events_df[
            events_df["owner_type"].isin(
                ["Research Lab", "Community Project/Non-Profit", "Startup", "Incumbent"]
            )
        ]
        events_df = events_df[events_df["change"] > 0]
        events_df = events_df.sort_values("date")
        events_df["year"] = events_df["date"].dt.year
        events_df = events_df[(events_df["year"] >= 2020) & (events_df["year"] < 2026)]

        # Create year groups
        def group_years(year):
            if year in [2020, 2021, 2022]:
                return "2020-22"
            elif year in [2023, 2024, 2025]:
                return "2023-25"
            return str(year)

        events_df["year_group"] = events_df["year"].apply(group_years)

        # Get unique owner types and colors
        owner_types = events_df["owner_type"].unique()
        color_palette = px.colors.qualitative.Set2
        colors = {
            owner_type: color_palette[i % len(color_palette)]
            for i, owner_type in enumerate(sorted(owner_types))
        }

        # Create figure
        fig = go.Figure()

        # Prepare data
        yearly_data = (
            events_df.groupby(["year_group", "owner_type"])["change"]
            .sum()
            .reset_index()
        )

        yearly_totals = yearly_data.groupby("year_group")["change"].sum().reset_index()
        yearly_totals.columns = ["year_group", "total"]

        yearly_data = yearly_data.merge(yearly_totals, on="year_group")
        yearly_data["percentage"] = (yearly_data["change"] / yearly_data["total"]) * 100

        year_order = ["2020-22", "2023-25"]

        # Line chart
        for owner_type in sorted(owner_types):
            owner_data = yearly_data[yearly_data["owner_type"] == owner_type]
            owner_data = owner_data.sort_values("year_group")
            color = colors[owner_type]

            fig.add_trace(
                go.Scatter(
                    x=owner_data["year_group"],
                    y=owner_data["percentage"],
                    name=owner_type.capitalize(),
                    mode="lines+markers",
                    line=dict(width=4, color=color),
                    marker=dict(size=12, color=color),
                    legendgroup=owner_type,
                    showlegend=True,
                )
            )

        # Update axes and layout
        fig.update_xaxes(
            title_text="Year Period",
            type="category",
            categoryorder="array",
            categoryarray=year_order,
            range=[-0.3, 1.3],
            title_font=dict(size=18),
            tickfont=dict(size=16),
        )

        fig.update_yaxes(
            title_text="Percentage (%)",
            title_font=dict(size=18),
            tickfont=dict(size=16),
        )

        fig.update_layout(
            title_text="Trend Between Periods",
            hovermode="x unified",
            template="plotly_white",
            height=500,
            width=700,
            font=dict(size=16),
            title_font=dict(size=20),
            legend=dict(
                orientation="v",
                yanchor="top",
                y=1,
                xanchor="left",
                x=1.02,
                font=dict(size=16),
            ),
        )

        return fig

    def plot_repos_created_bar(repos_df):
        """
        Create a grouped bar chart of repos created by percentage.
        """
        import plotly.graph_objects as go
        import plotly.express as px

        # Filter data
        repos_df = repos_df[
            repos_df["owner_type"].isin(
                ["Research Lab", "Community Project/Non-Profit", "Startup", "Incumbent"]
            )
        ]
        repos_df = repos_df.sort_values("Created")
        repos_df["year"] = repos_df["Created"].dt.year
        repos_df = repos_df[(repos_df["year"] >= 2020) & (repos_df["year"] < 2026)]

        # Create year groups
        def group_years(year):
            if year in [2020, 2021, 2022]:
                return "2020-22"
            elif year in [2023, 2024, 2025]:
                return "2023-25"
            return str(year)

        repos_df["year_group"] = repos_df["year"].apply(group_years)

        # Get unique owner types and colors
        owner_types = repos_df["owner_type"].unique()
        color_palette = px.colors.qualitative.Set2
        colors = {
            owner_type: color_palette[i % len(color_palette)]
            for i, owner_type in enumerate(sorted(owner_types))
        }

        # Create figure
        fig = go.Figure()

        # Prepare data - count repos by year_group and owner_type
        yearly_data = (
            repos_df.groupby(["year_group", "owner_type"])
            .size()
            .reset_index(name="count")
        )

        yearly_totals = yearly_data.groupby("year_group")["count"].sum().reset_index()
        yearly_totals.columns = ["year_group", "total"]

        yearly_data = yearly_data.merge(yearly_totals, on="year_group")
        yearly_data["percentage"] = (yearly_data["count"] / yearly_data["total"]) * 100

        year_order = ["2020-22", "2023-25"]

        # Grouped bar chart
        for owner_type in sorted(owner_types):
            owner_data = yearly_data[yearly_data["owner_type"] == owner_type]
            color = colors[owner_type]

            fig.add_trace(
                go.Bar(
                    x=owner_data["year_group"],
                    y=owner_data["percentage"],
                    name=owner_type.capitalize(),
                    marker_color=color,
                    legendgroup=owner_type,
                    showlegend=True,
                )
            )

        # Update axes and layout
        fig.update_xaxes(
            title_text="Year Period",
            type="category",
            categoryorder="array",
            categoryarray=year_order,
            title_font=dict(size=18),
            tickfont=dict(size=16),
        )

        fig.update_yaxes(
            title_text="Percentage (%)",
            title_font=dict(size=18),
            tickfont=dict(size=16),
        )

        fig.update_layout(
            title_text="Repos Created by Period (%)",
            hovermode="x unified",
            template="plotly_white",
            height=500,
            width=700,
            font=dict(size=16),
            title_font=dict(size=20),
            legend=dict(
                orientation="v",
                yanchor="top",
                y=1,
                xanchor="left",
                x=1.02,
                font=dict(size=16),
            ),
        )

        return fig

    def plot_repos_created_trend(repos_df):
        """
        Create a line chart showing the gradient between periods.
        """
        import plotly.graph_objects as go
        import plotly.express as px

        # Filter data
        repos_df = repos_df[
            repos_df["owner_type"].isin(
                ["Research Lab", "Community Project/Non-Profit", "Startup", "Incumbent"]
            )
        ]
        repos_df = repos_df.sort_values("Created")
        repos_df["year"] = repos_df["Created"].dt.year
        repos_df = repos_df[(repos_df["year"] >= 2020) & (repos_df["year"] < 2026)]

        # Create year groups
        def group_years(year):
            if year in [2020, 2021, 2022]:
                return "2020-22"
            elif year in [2023, 2024, 2025]:
                return "2023-25"
            return str(year)

        repos_df["year_group"] = repos_df["year"].apply(group_years)

        # Get unique owner types and colors
        owner_types = repos_df["owner_type"].unique()
        color_palette = px.colors.qualitative.Set2
        colors = {
            owner_type: color_palette[i % len(color_palette)]
            for i, owner_type in enumerate(sorted(owner_types))
        }

        # Create figure
        fig = go.Figure()

        # Prepare data - count repos by year_group and owner_type
        yearly_data = (
            repos_df.groupby(["year_group", "owner_type"])
            .size()
            .reset_index(name="count")
        )

        yearly_totals = yearly_data.groupby("year_group")["count"].sum().reset_index()
        yearly_totals.columns = ["year_group", "total"]

        yearly_data = yearly_data.merge(yearly_totals, on="year_group")
        yearly_data["percentage"] = (yearly_data["count"] / yearly_data["total"]) * 100

        year_order = ["2020-22", "2023-25"]

        # Line chart
        for owner_type in sorted(owner_types):
            owner_data = yearly_data[yearly_data["owner_type"] == owner_type]
            owner_data = owner_data.sort_values("year_group")
            color = colors[owner_type]

            fig.add_trace(
                go.Scatter(
                    x=owner_data["year_group"],
                    y=owner_data["percentage"],
                    name=owner_type.capitalize(),
                    mode="lines+markers",
                    line=dict(width=4, color=color),
                    marker=dict(size=12, color=color),
                    legendgroup=owner_type,
                    showlegend=True,
                )
            )

        # Update axes and layout
        fig.update_xaxes(
            title_text="Year Period",
            type="category",
            categoryorder="array",
            categoryarray=year_order,
            range=[-0.3, 1.3],
            title_font=dict(size=18),
            tickfont=dict(size=16),
        )

        fig.update_yaxes(
            title_text="Percentage (%)",
            title_font=dict(size=18),
            tickfont=dict(size=16),
        )

        fig.update_layout(
            title_text="Trend Between Periods",
            hovermode="x unified",
            template="plotly_white",
            height=500,
            width=700,
            font=dict(size=16),
            title_font=dict(size=20),
            legend=dict(
                orientation="v",
                yanchor="top",
                y=1,
                xanchor="left",
                x=1.02,
                font=dict(size=16),
            ),
        )

        return fig

    return (
        go,
        plot_repos_created_bar,
        plot_repos_created_trend,
        plot_star_history,
        plot_star_history_bar,
        plot_star_history_trend,
    )


@app.cell
def _(pd):
    # events_df.to_csv('star_events_history.csv')
    # Save the events for future use (to avoid re-fetching)
    events_df = pd.read_csv("star_events_history.csv")
    events_df.set_index("date", inplace=True)
    events_df.index = pd.to_datetime(events_df.index)
    events_df.reset_index(inplace=True)
    events_df.loc[
        events_df["repo"] == "OpenHealthForAll/open-health", "owner_type"
    ] = "User"
    # events_df = events_df[events_df['date']>'2018-01-01']
    return (events_df,)


@app.cell
def _(events_df, plot_star_history):
    # Fetch star history from GitHub API
    # Create and show the plot
    _fig = plot_star_history(events_df)
    # _fig.show()
    return


@app.cell
def _():
    # _fig = plot_star_history(events_df[events_df["change"] > 0])
    # _fig.show()
    return


@app.cell
def _(events_df, plot_star_history_bar, plot_star_history_trend):
    # _fig1 = plot_star_history_bar(events_df)
    # _fig1.show()

    # _fig2 = plot_star_history_unstack_bar(events_df)
    # _fig2.write_image("./nice_plots/star_by_category_bar.png")
    # _fig2.show()

    _fig3 = plot_star_history_bar(events_df)
    _fig3.write_image("./nice_plots/star_by_category_bar.png")

    _fig4 = plot_star_history_trend(events_df)
    _fig4.write_image("./nice_plots/star_by_category_trend.png")
    # _fig3.show()
    return


@app.cell(hide_code=True)
def _(df_health, go, pd, timedelta):
    df_health["active_until"] = df_health["Last Commit"] + timedelta(days=365)

    # Create events for each repository
    _events = []

    for _, _row in df_health.iterrows():
        # Repo becomes active (created)
        _events.append(
            {
                "date": _row["Created"],
                "change": 1,
                "repo": _row["Repository"],
                "owner_type": _row["owner_type"],
            }
        )

        # Repo becomes inactive (1 year after last commit)
        _events.append(
            {
                "date": _row["active_until"],
                "change": -1,
                "repo": _row["Repository"],
                "owner_type": _row["owner_type"],
            }
        )

    # Convert to dataframe and sort by date
    _events_df = pd.DataFrame(_events).sort_values("date")

    # Calculate cumulative active repos at each event
    _events_df["active_repos"] = _events_df["change"].cumsum()

    # Create the plot
    _fig = go.Figure()

    owner_types = _events_df["owner_type"].unique()

    for owner_type in owner_types:
        mask = _events_df["owner_type"] == owner_type
        owner_events = _events_df[mask].copy()
        owner_events["cumulative"] = owner_events["change"].cumsum()

        _fig.add_trace(
            go.Scatter(
                x=owner_events["date"],
                y=owner_events["cumulative"],
                mode="lines",
                name=owner_type.capitalize(),
                line=dict(width=2),
                # stackgroup='one',  # This creates a stacked area chart
            )
        )

    _fig.update_layout(
        title="GitHub Repository Activity Over Time",
        xaxis_title="Date",
        yaxis_title="Number of Active Repositories",
        hovermode="x unified",
        template="plotly_white",
        height=500,
    )

    # _fig.show()
    return


@app.cell
def _(df_health, plot_repos_created_bar, plot_repos_created_trend):
    _fig1 = plot_repos_created_bar(df_health)
    _fig1.write_image("./nice_plots/repos_created_bar.png")

    _fig2 = plot_repos_created_trend(df_health)
    _fig2.write_image("./nice_plots/repos_created_trend.png")
    return


@app.cell
def _(color_palette, go):
    def plot_repository_creation_by_subcategory(repos_df, subcategory_col="subcat"):
        """
        Create a stacked bar chart of repository creation by subcategory over time.
        Args:
            repos_df: DataFrame with columns ['Created', subcategory_col]
            subcategory_col: Name of the subcategory column to group by
        """
        # Extract year
        repos_df = repos_df.copy()
        repos_df["year"] = repos_df["Created"].dt.year
        repos_df = repos_df.sort_values("year")

        # Count repos by year and subcategory
        yearly_data = (
            repos_df.groupby(["year", subcategory_col]).size().reset_index(name="count")
        )

        # Get unique subcategories and assign colors
        subcategories = sorted(yearly_data[subcategory_col].unique())

        colors = {
            subcat: color_palette[i % len(color_palette)]
            for i, subcat in enumerate(subcategories)
        }

        # Create figure
        fig = go.Figure()

        for subcat in subcategories:
            subcat_data = yearly_data[yearly_data[subcategory_col] == subcat]

            fig.add_trace(
                go.Bar(
                    x=subcat_data["year"],
                    y=subcat_data["count"],
                    name=subcat,
                    marker_color=colors[subcat],
                )
            )

        all_years = sorted(yearly_data["year"].unique())

        fig.update_layout(
            title="Repository Creation by Subcategory Over Time",
            xaxis_title="Year",
            yaxis_title="Number of Repositories",
            barmode="stack",
            template="plotly_white",
            height=400,
            legend=dict(title=dict(text="Subcat")),
            xaxis=dict(
                tickmode="array",
                tickvals=all_years,
                ticktext=[str(year) for year in all_years],
            ),
        )

        return fig

    def plot_repository_creation_by_category(repos_df, category_col="category"):
        """
        Create a stacked bar chart of repository creation by category over time.
        Args:
            repos_df: DataFrame with columns ['Created', category_col]
            category_col: Name of the category column to group by
        """
        # Extract year
        repos_df = repos_df.copy()
        repos_df["year"] = repos_df["Created"].dt.year

        # Count repos by year and category
        yearly_data = (
            repos_df.groupby(["year", category_col]).size().reset_index(name="count")
        )

        # Get unique categories and assign colors
        categories = sorted(yearly_data[category_col].unique())
        colors = {
            cat: color_palette[i % len(color_palette)]
            for i, cat in enumerate(categories)
        }

        # Create figure
        fig = go.Figure()

        for cat in categories:
            cat_data = yearly_data[yearly_data[category_col] == cat]

            fig.add_trace(
                go.Bar(
                    x=cat_data["year"],
                    y=cat_data["count"],
                    name=cat,
                    marker_color=colors[cat],
                )
            )

        # Get all unique years for tick values
        all_years = sorted(yearly_data["year"].unique())

        fig.update_layout(
            title="Repository Creation by Category Over Time",
            xaxis_title="Year",
            yaxis_title="Number of Repositories",
            barmode="stack",
            template="plotly_white",
            height=400,
            legend=dict(title=dict(text="Category")),
            xaxis=dict(
                tickmode="array",
                tickvals=all_years,
                ticktext=[str(year) for year in all_years],
            ),
        )

        return fig

    def plot_cumulative_adoption_by_standard(repos_df, standard_col="standard"):
        """
        Create a line chart showing cumulative repository adoption by standard over time.
        The two largest standards have labels directly on the graph.

        Args:
            repos_df: DataFrame with columns ['date_created', standard_col]
            standard_col: Name of the standard column containing lists of standards
        """
        import random
        from datetime import timedelta

        repos_df = repos_df.copy()
        repos_df = repos_df.sort_values("Created")

        # Explode the list column so each standard gets its own row
        repos_expanded = repos_df.explode(standard_col)

        # Remove rows where standard is None or empty
        repos_expanded = repos_expanded[repos_expanded[standard_col].notna()]
        repos_expanded = repos_expanded[repos_expanded[standard_col] != ""]

        # Get unique standards
        standards = repos_expanded[standard_col].unique()
        print(sorted(standards))
        color_map_standards = [
            "CQL",
            "DICOM",
            "iomt",
            "HL7 CDA",
            "HL7v2",
            "OMOP-CDM",
            "SNOMED CT",
            "hpo",
            "icd-10",
            "FHIR",
            "loinc",
            "openEHR",
        ]
        # Assign colors
        colors = {
            std: color_palette[i % len(color_palette)]
            for i, std in enumerate(color_map_standards)
        }

        # Get the two largest standards (by final cumulative count)
        final_counts = {}
        for standard in standards:
            std_data = repos_expanded[repos_expanded[standard_col] == standard]
            final_counts[standard] = len(std_data)

        top_two_standards = sorted(
            final_counts.items(), key=lambda x: x[1], reverse=True
        )[:2]
        top_two_standards = [std for std, _ in top_two_standards]

        # Create figure
        fig = go.Figure()

        for standard in sorted(standards):
            std_data = repos_expanded[repos_expanded[standard_col] == standard].copy()
            std_data = std_data.sort_values("Created")
            std_data["cumulative"] = range(1, len(std_data) + 1)

            fig.add_trace(
                go.Scatter(
                    x=std_data["Created"],
                    y=std_data["cumulative"],
                    name=standard,
                    mode="lines",
                    line=dict(width=3, color=colors[standard]),
                    showlegend=False,
                )
            )

            # Add text annotation for the two largest standards
            if standard in top_two_standards:
                # Get the last point
                last_x = std_data["Created"].iloc[-1]
                last_y = std_data["cumulative"].iloc[-1]

                # Add random jitter to y-position to avoid overlap
                # y_jitter = random.uniform(-30, 30)

                fig.add_annotation(
                    x=last_x - timedelta(days=500),
                    y=last_y + 15,
                    text=standard,
                    showarrow=False,
                    xanchor="left",
                    xshift=10,
                    font=dict(size=18, color=colors[standard]),
                    bgcolor="white",
                    opacity=0.8,
                )

        fig.update_layout(
            title="Cumulative Repository Adoption by Standard Over Time",
            xaxis_title="Year",
            yaxis_title="Total Repositories (Cumulative)",
            template="plotly_white",
            height=400,
            width=800,
            hovermode="x unified",
        )

        fig.update_layout(
            title_font_size=20,
            font=dict(size=14),  # Affects axis labels and tick labels
            # ... rest of your existing parameters
        )

        return fig

    def plot_cumulative_repos_by_category(repos_df, category_col="category"):
        """
        Create a line chart showing cumulative number of repositories by category over time.
        The two largest categories have labels directly on the graph.

        Args:
            repos_df: DataFrame with columns ['Created', category_col]
            category_col: Name of the category column to group by
        """
        import random
        from datetime import timedelta

        repos_df = repos_df.copy()
        repos_df = repos_df.sort_values("Created")

        # Get unique categories
        categories = repos_df[category_col].unique()

        # Assign colors
        colors = {
            cat: color_palette[i % len(color_palette)]
            for i, cat in enumerate(sorted(categories))
        }

        # Get the two largest categories (by final cumulative count)
        final_counts = {}
        for category in categories:
            cat_data = repos_df[repos_df[category_col] == category]
            final_counts[category] = len(cat_data)

        top_two_categories = sorted(
            final_counts.items(), key=lambda x: x[1], reverse=True
        )
        top_two_categories = [cat for cat, _ in top_two_categories]

        # Create figure
        fig = go.Figure()

        for category in sorted(categories):
            cat_data = repos_df[repos_df[category_col] == category].copy()
            cat_data["cumulative"] = range(1, len(cat_data) + 1)

            fig.add_trace(
                go.Scatter(
                    x=cat_data["Created"],
                    y=cat_data["cumulative"],
                    name=category,
                    mode="lines",
                    line=dict(width=3, color=colors[category]),
                    showlegend=False,
                )
            )

            # Add text annotation for the two largest categories
            if category in top_two_categories:
                # Get the last point
                last_x = cat_data["Created"].iloc[-1]
                last_y = cat_data["cumulative"].iloc[-1]

                # Add random jitter to y-position to avoid overlap
                # y_jitter = random.uniform(-30, 30)

                fig.add_annotation(
                    x=last_x - timedelta(days=1300),
                    y=last_y,
                    text=category,
                    showarrow=False,
                    xanchor="left",
                    xshift=10,
                    font=dict(size=20, color=colors[category]),
                    bgcolor="white",
                    opacity=0.8,
                )

        fig.update_layout(
            title="Cumulative Number of Repositories by Category Over Time",
            xaxis_title="Date",
            yaxis_title="Cumulative Number of Repositories",
            template="plotly_white",
            height=550,
            width=800,
            hovermode="x unified",
        )

        fig.update_layout(
            title_font_size=20,
            font=dict(size=14),  # Affects axis labels and tick labels
            # ... rest of your existing parameters
        )

        return fig

    def plot_cumulative_adoption_by_language(
        repos_df, language_col="language", top_n=10
    ):
        """
        Create a line chart showing cumulative repository adoption by language over time.
        Shows only the top N languages by total repository count.
        The two largest languages have labels directly on the graph.

        Args:
            repos_df: DataFrame with columns ['date_created', language_col]
            language_col: Name of the language column containing lists of languages
            top_n: Number of top languages to display (default: 10)
        """
        import random

        repos_df = repos_df.copy()
        repos_df = repos_df.sort_values("Created")

        # Explode the list column so each language gets its own row
        repos_expanded = repos_df.explode(language_col)

        # Remove rows where language is None or empty
        repos_expanded = repos_expanded[repos_expanded[language_col].notna()]
        repos_expanded = repos_expanded[repos_expanded[language_col] != ""]

        # Get top N languages by count
        language_counts = repos_expanded[language_col].value_counts()
        top_languages = language_counts.head(top_n).index.tolist()

        # Filter to only top languages
        repos_expanded = repos_expanded[
            repos_expanded[language_col].isin(top_languages)
        ]

        # Assign colors
        # color_palette = px.colors.qualitative.Set1
        custom_color_order = [
            "Java",
            "Jupyter Notebook",
            "Python",
            "JavaScript",
            "TypeScript",
        ]
        colors = {
            lang: color_palette[i % len(color_palette)]
            for i, lang in enumerate(custom_color_order)
        }

        # Get the two largest languages (by final cumulative count)
        final_counts = {}
        for language in top_languages:
            lang_data = repos_expanded[repos_expanded[language_col] == language]
            final_counts[language] = len(lang_data)

        top_two_languages = sorted(
            final_counts.items(), key=lambda x: x[1], reverse=True
        )[:5]
        top_two_languages = [lang for lang, _ in top_two_languages]

        # Create figure
        fig = go.Figure()

        y_jitter = [0, 10, -2, 0, 0]
        print(sorted(top_languages))
        for i, language in enumerate(sorted(top_languages)):
            lang_data = repos_expanded[repos_expanded[language_col] == language].copy()
            lang_data = lang_data.sort_values("Created")
            lang_data["cumulative"] = range(1, len(lang_data) + 1)

            fig.add_trace(
                go.Scatter(
                    x=lang_data["Created"],
                    y=lang_data["cumulative"],
                    name=language,
                    mode="lines",
                    line=dict(width=3, color=colors[language]),
                    showlegend=False,
                )
            )

            # Add text annotation for the two largest languages
            if language in top_two_languages:
                # Get the last point
                last_x = lang_data["Created"].iloc[-1]
                last_y = lang_data["cumulative"].iloc[-1]

                # Add random jitter to y-position to avoid overlap

                fig.add_annotation(
                    x=last_x,
                    y=last_y + y_jitter[i],
                    text=language,
                    showarrow=False,
                    xanchor="left",
                    xshift=10,
                    font=dict(size=16, color=colors[language]),
                    bgcolor="white",
                    opacity=0.8,
                )

        fig.update_layout(
            title=f"Cumulative Repository Adoption by Language (Top {top_n})",
            xaxis_title="Year",
            yaxis_title="Total Repositories (Cumulative)",
            template="plotly_white",
            height=400,
            width=800,
            hovermode="x unified",
        )

        fig.update_layout(
            title_font_size=20,
            font=dict(size=14),  # Affects axis labels and tick labels
            # ... rest of your existing parameters
        )

        return fig

    return (
        plot_cumulative_adoption_by_language,
        plot_cumulative_adoption_by_standard,
        plot_cumulative_repos_by_category,
        plot_repository_creation_by_category,
        plot_repository_creation_by_subcategory,
    )


@app.cell
def _(
    df_health,
    plot_repository_creation_by_category,
    plot_repository_creation_by_subcategory,
):
    df_health_r = df_health[df_health["Created"] > "2016-01-01"]
    fig1 = plot_repository_creation_by_subcategory(
        df_health_r[df_health_r["Category"] == "Interoperability"],
        subcategory_col="Subcat",
    )
    fig1.write_image("./nice_plots/interoperablity_subcat_timeline.png")
    fig2 = plot_repository_creation_by_subcategory(
        df_health_r[df_health_r["Category"] == "Model Development"],
        subcategory_col="Subcat",
    )
    fig2.write_image("./nice_plots/model_development_subcat_timeline.png")
    fig3 = plot_repository_creation_by_category(df_health_r, category_col="Category")
    fig3.write_image("./nice_plots/hero_healthcare_ai_repo_timeline.png")
    return (df_health_r,)


@app.cell
def _(
    df_health,
    df_health_r,
    plot_cumulative_adoption_by_language,
    plot_cumulative_adoption_by_standard,
    plot_cumulative_repos_by_category,
):
    fig4 = plot_cumulative_adoption_by_standard(
        df_health[~df_health["standards_list"].isin([["None/Unknown"]])],
        standard_col="standards_list",
    )
    big_cats = [
        "Interoperability",
        "HAI engineering",
        "Infrastructure",
        "Model Development",
    ]
    fig5 = plot_cumulative_repos_by_category(
        df_health[df_health["Category"].isin(big_cats)], category_col="Category"
    )
    fig6 = plot_cumulative_adoption_by_language(
        df_health_r, language_col="Language", top_n=5
    )
    return fig4, fig5, fig6


@app.cell
def _(fig6):
    fig6.show()
    fig6.write_image("./nice_plots/language_timeline.png", scale=2)
    return


@app.cell
def _(fig5):
    fig5.show()
    fig5.write_image("./nice_plots/cumulative_repo_timeline.png", scale=2)
    return


@app.cell
def _(fig4):
    fig4.show()
    fig4.write_image("./nice_plots/cumulative_standard_timeline.png", scale=2)
    return


@app.cell
def _():
    return


@app.cell
def _():
    return


@app.cell
def _():
    return


@app.cell
def _():
    return


@app.cell(column=3, hide_code=True)
def _(mo):
    mo.md(
        r"""
    ## FHIR Dominating
    """
    )
    return


@app.cell
def _(color_palette, df_health, px):
    df_hai = df_health[df_health["Category"] == "HAI engineering"]

    _subcat_counts = df_hai["Subcat"].value_counts()

    _fig_subcat = px.bar(
        x=_subcat_counts.values,
        y=_subcat_counts.index,
        orientation="h",
        title=f"AI Machine go brrrrrrrrrrr",
        subtitle="Breakdown of HAI Engineering Repos",
        labels={"x": "Number of Repositories", "y": "Subcategory"},
        # color=_subcat_counts.values,
        # color_continuous_scale='Teal'
        color_discrete_sequence=color_palette,
        template="plotly_white",
    )

    # Add values at the end of each bar
    _fig_subcat.update_traces(
        text=_subcat_counts.values, textposition="outside", textfont=dict(size=12)
    )

    _fig_subcat.update_layout(height=500, yaxis={"categoryorder": "total ascending"})

    _fig_subcat.update_layout(yaxis_title=None)
    _fig_subcat.update_layout(legend=None)
    _fig_subcat.update_layout()
    _fig_subcat.show()
    _fig_subcat.write_image("./nice_plots/hai_engineering.png")
    return


@app.cell
def _():
    return


if __name__ == "__main__":
    app.run()
